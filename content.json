[{"title":"关于View","date":"2018-02-02T08:52:37.000Z","path":"2018/02/02/android-view/","text":"学习目标学习关于View的知识 View的getWidth()和getMeasuredWidth()有什么区别吗？ 如何在onCreate中拿到View的宽度和高度？","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"关于startActivityForResult","date":"2018-02-02T08:12:25.000Z","path":"2018/02/02/startactvityforresult/","text":"学习目标理解startActivityForResult startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？ Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？ 注意以下基于 7.0 源码讨论。 startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？使用场景 用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。 requestCode 解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。 该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。 为什么 requestCode &lt; 0 时收不到结果？ ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空// 链接：Cross Reference: /frameworks/base/services/core/ja… if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) { // 只有非负数时新的 ActivityRecord 对象的 resultTo 变量才 指向发起者 ActivityRecord 对象 resultRecord = sourceRecord; } 在 ActivityStack 收到 finishActivityResultsLocked 时，读取ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量。 在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了 resultCode 异步调用结果码，告诉调用者成功/失败/其它信息 该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？ setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中: 最早 Activity 构造器阶段 最晚 Activity.finalize 内存回收阶段 // Home 键 + 不保留后台 Activity 可触发 onDestroy @Override protected void onDestroy() { super.onDestroy(); Log.d(TAG, &quot;onDestroy() called&quot;); new ReqGC().start(); } @Override protected void finalize() throws Throwable { Log.d(TAG, &quot;finalize() called&quot;); finish(); super.finalize(); } @Override public void finish() { Log.d(TAG, &quot;finish() called&quot;); setResult(RESULT_OK, new Intent().putExtra(&quot;key&quot;, &quot;resultData&quot;)); super.finish(); } // 不泄漏 Activity 对象 static class ReqGC { public void start() { final Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { System.gc(); handler.postDelayed(this, 10); } }, 10); } } setResult不可以位于finish之后 如果位于finish之后执行，那信息无法传递给源 Activity 从代码可以看出setResult和finish类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据。 线程安全问题 Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护 支持后台线程和 UI 线程分别进行 setResult 和 finish 但是为什么需要加锁保护这两个信息？需要「解决什么问题」？ API 设计/数据组装问题 底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？ 使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息 API 内部原理/数据处理流程 链接：6575830-cd7aada2f45de461.png (PNG Image, 3632 × 34… 关键节点： Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体 AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中 AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时 AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题 基本原则:源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据 Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调 链接：Cross Reference: /frameworks/base/services/core/ja… Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调 链接：Cross Reference: /frameworks/base/services/java/co… 通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"Activity的启动模式","date":"2018-02-02T06:10:52.571Z","path":"2018/02/02/activity-start/","text":"学习目标理解Activity的启动模式 Activity的启动模式有哪几种，分别用于什么场景？ 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？ Activity的启动模式有哪几种，分别用于什么场景？ standard: 标准模式 系统的默认模式。一种多实例模式，每次启动一个Activity都会重新创建一个新的实例。被启动的Activit会被放入启动者的栈中，如果启动者是除Activity之外的Context，如Application，此时没有任务栈，就会报错，此时需指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。没有特殊需求都默认是这种模式。 singleTop: 栈顶复用模式 如果一个Activity的实例已经在栈顶存在，启动这个Activity时，不会创建新的Activity，而是回调onNewIntent方法，如果不是在栈顶存在，则创建一个新的实例。适合接收通知启动的内容显示页面，当接收到多条新闻推送时，用户展示新闻的Activity设置成此模式，根据传过来的intent数据显示不同的新闻信息，不会起动多个activity。 singleTask: 栈内复用模式 一种单实例模式，只要Activity的实例在一个栈中存在，再一次启动Activity时都不会重新创建实例，只回调onNewIntent方法，并从栈中清空这个Activity实例上的所有Activity实例。适合作为程序的入口点，例如浏览器的主页面，不管多少应用启动浏览器，只会启动主页面一次，其余情况都只回调onNewIntent方法，并且会清空主页面上的其他页面。 singleInstance: 单实例模式 具有singleTask的所有特性，设置此模式的Activity只能单独存在在一个任务栈中。 一个例子：闹铃响铃页面，你在16点设置了一个闹钟，在15点58的时候，你启动了闹钟设置页面，并按home键返回桌面，在15点59的时候你打开微信和朋友聊天，16点的时候闹钟响了，并且弹出一个对话框形式的Activity （AlarmAlertActivity，这个Activity是以singleInstance模式打开的）提示你16点到了，这时候你按返回键，返回的是微信聊天页，不是闹钟设置页面，因为AlarmAlertActivity以singleInstance模式打开，栈里只有它一个实例，退出后这个任务栈空了，如果以singleTask打开，这时候返回的是闹钟设置页面。 清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？onNewIntent 在singleTop、singleTask、singleInstance模式下再次启动相同的Activity，如果期望只有一个实例存在，再次启动就会调用onNewIntent，在onNewIntent中可以通过调用setIntents刷新Intent数据 onConfigurationChanged 当Android设置正在运行app时，如果设备的语言，屏幕方向，键盘的参数改变了，默认会销毁当前Activity并重新创建一次Activity来重新加载新的配置信息。为了防止系统销毁，可以再AndroidManifest.xml文件中给Activity设置android:configChanges属性，可选值有[&quot;mcc&quot;,&quot;mnc&quot;,&quot;locale&quot;,&quot;touchscreen&quot;,&quot;keyboard&quot;,&quot;keyboardHidden&quot;, &quot;navigation&quot;,&quot;screenLayout&quot;,&quot;fontScale&quot;,&quot;uiMode&quot;, &quot;orientation&quot;,&quot;density&quot;,&quot;screenSize&quot;,&quot;smallestScreenSize&quot;]，申明的配置发生改变时，将不会重启Activity，而是回调onConfigurationChanged方法。如果设置的属性是orientation，当屏幕方向发生变化的时候，会阻止系统销毁Activity重新创建，而是保持运行，回调onConfigurationChanged方法，我们需要在onConfigurationChanged中做屏幕方向发生改变的操作，onConfigurationChanged会传递一个Configuration对象，通过读取这个对象的配置信息，来自行适配新的UI页面。 注：从Android 3.2(API 13)开始，当设备屏幕方向发生变化的时候，screenSize 也会发生变化，因此需要设置android:configChanges=&quot;orientation|screenSize&quot;","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"理解Service","date":"2018-02-01T13:53:44.006Z","path":"2018/02/01/android-service/","text":"学习目标清晰地理解Service。 Service的start和bind状态有什么区别？ 同一个Service，先startService，然后再bindService，如何把它停止掉？ 你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service的start和bind状态有什么区别： start启动的service，service有独立的生命周期，不依赖该组件； 多次调用start方法，会重复调用onStartCommand方法； start启动的service，必须调用stopService或者stopSelfl来停止service（IntentService会自动调用stopSelf方法）； 多次调用bind方法，只会调用一次onBind方法，bind绑定的service，service依赖这些组件，这些组件全部销毁后，service也会一起销毁。 同一个Service，先startService，然后再bindService，如何把它停止掉？ 不论被start多少次，只需要stopService或者stopSelf一次； 调用n次bindService只需要调用一次unBindService； 所以，需要调用一次stopService（或者stopSelf）和一次unBindService方法，执行顺序没有要求，最后一个stopService（stopSelf）或者unBindService会导致Service执行onDestory方法。 你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 一共有如下4种返回值： /**为了兼容版本，在Service被杀死后,并不保证onStartCommand会被再一次调用*/ public static final int START_STICKY_COMPATIBILITY = 0; /**Service被杀死后，保留启动状态，但是不保存intent， 之后系统会尝试重启Service，并重新回调onStartCommand方法， 如果接下来没有其他start命令，intent会为空， 因此要注意onStartCommand对intent的非空判断*/ public static final int START_STICKY = 1; /**常规操作，除非在Service被杀死前还有组件调用startService, 否则系统不会保留启动状态并重启该Service*/ public static final int START_NOT_STICKY = 2; /**Service被杀死后，系统会组织一次Service的重启（除非在那之前调用了 stopSelf方法），被杀死前最后一次传递的intent将重新执行，该flag不会 传递空的intent。*/ public static final int START_REDELIVER_INTENT = 3; Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service默认是运行在主线程的，其生命周期方法也是运行在主线程： 因此，如果要在Service中进行耗时操作，必须另起线程，或者用IntentService，否则很容易引起ANR。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"理解Java中的synchronized关键字","date":"2018-02-01T13:40:42.542Z","path":"2018/02/01/java-sunc/","text":"学习目标理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。 有如下一个类A class A { public synchronized void a() { System.out.println(&quot;a&quot;+System.currentTimeMillis()); } public synchronized void b() { System.out.println(&quot;b&quot;+System.currentTimeMillis()); } } 然后创建两个对象 A a1 = new A(); A a2 = new A(); 然后在两个线程中并发访问如下代码： Thread a1.a(); Thread a2.a(); public class Test { public static void main(String[] args) { A a1 = new A(); A a2 = new A(); new Thread(new Runnable() { @Override public void run() { System.out.println(System.currentTimeMillis()); a1.a(); } }).start(); new Thread(new Runnable() { @Override public void run() { System.out.println(System.currentTimeMillis()); a2.a(); } }).start(); } } 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？ class A { public static synchronized void a() { System.out.println(&quot;a&quot;+System.currentTimeMillis()); } public static synchronized void b() { System.out.println(&quot;b&quot;+System.currentTimeMillis()); } } 验证没有加static的时候结果是这样的: 加了static的时候结果是这样的: 可以看出，没有static时不能同步，有static时能同步。 Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 Synchronized主修修饰对象为以下三种： 修饰普通方法：一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象，如果多个线程不同对象访问该方法，则无法保证同步。 修饰静态方法：由于静态方法是类方法，所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 修饰代码块：其中普通代码块，如Synchronized（obj），这里的obj，可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 Synchronized方法控制范围较大，它会同步对象中所有Synchronized方法的代码。 Synchronized代码块控制范围较小，它只会同步代码块中的代码，而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","date":"2018-01-30T08:56:01.913Z","path":"2018/01/30/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]