{"meta":{"title":"蓝调华尔兹","subtitle":"每个人都曾经穿越不为人知的黑暗","description":"没有比脚更长的路，走过去，前面是个天！","author":"YU.LIAO","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-02-01T06:57:35.000Z","updated":"2018-02-01T07:38:59.025Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-02-01T06:59:50.000Z","updated":"2018-02-01T07:39:24.620Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"android-service","slug":"android-service","date":"2018-02-01T13:53:44.006Z","updated":"2018-02-02T03:21:26.054Z","comments":true,"path":"2018/02/01/android-service/","link":"","permalink":"http://yoursite.com/2018/02/01/android-service/","excerpt":"","text":"学习目标清晰地理解Service。 Service的start和bind状态有什么区别？ 同一个Service，先startService，然后再bindService，如何把它停止掉？ 你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service的start和bind状态有什么区别： start启动的service，service有独立的生命周期，不依赖该组件； 多次调用start方法，会重复调用onStartCommand方法； start启动的service，必须调用stopService或者stopSelfl来停止service（IntentService会自动调用stopSelf方法）； 多次调用bind方法，只会调用一次onBind方法，bind绑定的service，service依赖这些组件，这些组件全部销毁后，service也会一起销毁。 同一个Service，先startService，然后再bindService，如何把它停止掉？ 不论被start多少次，只需要stopService或者stopSelf一次； 调用n次bindService只需要调用一次unBindService； 所以，需要调用一次stopService（或者stopSelf）和一次unBindService方法，执行顺序没有要求，最后一个stopService（stopSelf）或者unBindService会导致Service执行onDestory方法。 你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？ 一共有如下4种返回值： /**为了兼容版本，在Service被杀死后,并不保证onStartCommand会被再一次调用*/ public static final int START_STICKY_COMPATIBILITY = 0; /**Service被杀死后，保留启动状态，但是不保存intent， 之后系统会尝试重启Service，并重新回调onStartCommand方法， 如果接下来没有其他start命令，intent会为空， 因此要注意onStartCommand对intent的非空判断*/ public static final int START_STICKY = 1; /**常规操作，除非在Service被杀死前还有组件调用startService, 否则系统不会保留启动状态并重启该Service*/ public static final int START_NOT_STICKY = 2; /**Service被杀死后，系统会组织一次Service的重启（除非在那之前调用了 stopSelf方法），被杀死前最后一次传递的intent将重新执行，该flag不会 传递空的intent。*/ public static final int START_REDELIVER_INTENT = 3; Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？ Service默认是运行在主线程的，其生命周期方法也是运行在主线程： 因此，如果要在Service中进行耗时操作，必须另起线程，或者用IntentService，否则很容易引起ANR。","categories":[{"name":"android学习计划","slug":"android学习计划","permalink":"http://yoursite.com/categories/android学习计划/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"理解Java中的synchronized关键字","slug":"java-sunc","date":"2018-02-01T13:40:42.542Z","updated":"2018-02-01T13:48:08.939Z","comments":true,"path":"2018/02/01/java-sunc/","link":"","permalink":"http://yoursite.com/2018/02/01/java-sunc/","excerpt":"","text":"学习目标理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。 有如下一个类A class A { public synchronized void a() { System.out.println(&quot;a&quot;+System.currentTimeMillis()); } public synchronized void b() { System.out.println(&quot;b&quot;+System.currentTimeMillis()); } } 然后创建两个对象 A a1 = new A(); A a2 = new A(); 然后在两个线程中并发访问如下代码： Thread a1.a(); Thread a2.a(); public class Test { public static void main(String[] args) { A a1 = new A(); A a2 = new A(); new Thread(new Runnable() { @Override public void run() { System.out.println(System.currentTimeMillis()); a1.a(); } }).start(); new Thread(new Runnable() { @Override public void run() { System.out.println(System.currentTimeMillis()); a2.a(); } }).start(); } } 请问二者能否构成线程同步？ 如果A的定义是下面这种呢？ class A { public static synchronized void a() { System.out.println(&quot;a&quot;+System.currentTimeMillis()); } public static synchronized void b() { System.out.println(&quot;b&quot;+System.currentTimeMillis()); } } 验证没有加static的时候结果是这样的: 加了static的时候结果是这样的: 可以看出，没有static时不能同步，有static时能同步。 Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。 Synchronized主修修饰对象为以下三种： 修饰普通方法：一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象，如果多个线程不同对象访问该方法，则无法保证同步。 修饰静态方法：由于静态方法是类方法，所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。 修饰代码块：其中普通代码块，如Synchronized（obj），这里的obj，可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。 Synchronized方法控制范围较大，它会同步对象中所有Synchronized方法的代码。 Synchronized代码块控制范围较小，它只会同步代码块中的代码，而位于代码块之外的代码是可以被多个线程访问的。 简单来说 就是 Synchronized代码块更加灵活精确。","categories":[{"name":"Android学习计划","slug":"Android学习计划","permalink":"http://yoursite.com/categories/Android学习计划/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-30T08:56:01.913Z","updated":"2018-02-01T07:45:36.256Z","comments":true,"path":"2018/01/30/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo笔记","slug":"hexo笔记","permalink":"http://yoursite.com/categories/hexo笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}