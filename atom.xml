<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝调华尔兹</title>
  
  <subtitle>每个人都曾经穿越不为人知的黑暗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-02T15:07:55.595Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YU.LIAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于View</title>
    <link href="http://yoursite.com/2018/02/02/android-view/"/>
    <id>http://yoursite.com/2018/02/02/android-view/</id>
    <published>2018-02-02T08:52:37.000Z</published>
    <updated>2018-02-02T15:07:55.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>学习关于View的知识</p><ol><li>View的getWidth()和getMeasuredWidth()有什么区别吗？</li><li>如何在onCreate中拿到View的宽度和高度？</li></ol><h3 id="View的getWidth-和getMeasuredWidth-有什么区别吗？"><a href="#View的getWidth-和getMeasuredWidth-有什么区别吗？" class="headerlink" title="View的getWidth()和getMeasuredWidth()有什么区别吗？"></a>View的getWidth()和getMeasuredWidth()有什么区别吗？</h3><blockquote><p>View的宽高是由View本身和parent容器共同决定的。</p><p>getMeasuredWidth()和getWidth()分别对应View的measure与layout阶段，getMeasuredWidth()(int widthMeasureSpec,int heightMeasureSpec)方法中获得，getWidth()是在onLayout后获得。大部分情况下他们是一样的，也有一些不相同的情况，例如，在父View的onLayout中或者在View本身的onDraw方法中调用measure(0,0)(其中参数0可以自己设置)方法，两者的结果可能会不同。</p></blockquote><p>getWidth()源码：</p><p><img src="/2018/02/02/android-view/getWidth.png" alt="getWidth"></p><blockquote><p>可以看出，getWidth()返回的是右边的坐标减去左边的坐标，这是要在布局以后才能确定的，也就是说要在onLayout后才能得到，所以getWidth()是在View设定好布局后整个View的宽度。</p></blockquote><p>getMeasuredWidth()源码:</p><p><img src="/2018/02/02/android-view/getMeasureWidth.png" alt="getMeasureWidth"></p><blockquote><p>可以看出getMeasuredWidth返回的是原始测量宽度，所以getMeasuredWidth是对View内容进行测量后得到View内容占据的宽度。</p><p>在fuView的onLayout中或者在View本身的onDraw方法中调用measure(0,0)(其中参数0可以自己设置)方法时，如下:</p></blockquote><p><img src="/2018/02/02/android-view/testActivity.png" alt="testActivity"></p><p><img src="/2018/02/02/android-view/testXml.png" alt="testXml"><br>此时的打印结果为:<br><img src="/2018/02/02/android-view/testResult.png" alt="testResult"></p><blockquote><p>所以可以得出结论:getWidth()是View设定好布局后整个View的宽度，getMeasureWidth()是对View上的内容进行测量后得到的View内容的宽度。</p></blockquote><h3 id="如何在onCreate中拿到View的宽度和高度？"><a href="#如何在onCreate中拿到View的宽度和高度？" class="headerlink" title="如何在onCreate中拿到View的宽度和高度？"></a>如何在onCreate中拿到View的宽度和高度？</h3><blockquote><p>onCreate中获取View的宽高有3中方式</p><p>我们先定义一个获取View宽高的方法:</p></blockquote><p><img src="/2018/02/02/android-view/getWH.png" alt="getWH"></p><ul><li><p>View.post(Runnable runnable)</p><p>  利用View的通信机制，发送一个message到Message queue中，当View layout处理完成时，自动发送消息，通知UI线程，取巧的获取View的宽高，代码简洁，使用简单，相对比ViewTreeObserver监听处理，还不需要手动移除观察者监听事件。</p></li></ul><p><img src="/2018/02/02/android-view/runnable.png" alt="runnable"><br>此时打印结果：<br><img src="/2018/02/02/android-view/runnableResult.png" alt="runnableResult"></p><ul><li><p>ViewTreeObserver.addGloblLayoutListener(OnGlobalLayoutListener listener)</p><p>  监听View的onLayout绘制过程，一旦layout发生变化，立即回调onLayoutChange方法。<br><img src="/2018/02/02/android-view/treeGlobal.png" alt="treeGlobal"><br>此时打印结果:<br><img src="/2018/02/02/android-view/treeGlobalResult.png" alt="treeGlobalRresult"></p></li></ul><blockquote><p>   注意：使用完后要调用removeOnGlobalLayoutListener方法移除监听事件，<br>   避免后续每一次发生全局View变化时都会回调这个事件，影响性能。</p></blockquote><ul><li><p>View.measure(int widthMeasureSpec,int heightMeaseureSpec)</p><pre><code>View.MeasureSpec.makeMeasureSpec(@IntRange(from = 0,to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,@MeasureSpecMode int mode)</code></pre><p>  其中，MeasureSpec.MODE_SHIFT = 30    </p><p>  size 的最大值为（1 &lt;&lt; 30）-1，即用30位二进制表示，最大为30个1(2^30 - 1);<br><img src="/2018/02/02/android-view/measure.png" alt="measure"><br>打印结果:<br><img src="/2018/02/02/android-view/measureResult.png" alt="measureResult"><br><img src="/2018/02/02/android-view/measure1.png" alt="measure1"><br>打印结果:<br><img src="/2018/02/02/android-view/measure1Result.png" alt="measure1Result"></p></li></ul><h3 id="除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged-boolean-hasFocus-中获取"><a href="#除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged-boolean-hasFocus-中获取" class="headerlink" title="除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged(boolean hasFocus)中获取"></a>除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged(boolean hasFocus)中获取</h3><p>源码：<br><img src="/2018/02/02/android-view/focussource.png" alt="focussource"><br><img src="/2018/02/02/android-view/focus.png" alt="focus"><br>打印结果:<br><img src="/2018/02/02/android-view/focusResult.png" alt="focusResult"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;学习关于View的知识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View的getWidth()和getMeasuredWidth()有什么
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>关于startActivityForResult</title>
    <link href="http://yoursite.com/2018/02/02/startactvityforresult/"/>
    <id>http://yoursite.com/2018/02/02/startactvityforresult/</id>
    <published>2018-02-02T08:12:25.000Z</published>
    <updated>2018-02-02T09:13:04.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解startActivityForResult</p><ol><li><p>startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？</p></li><li><p>Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？</p></li></ol><p>注意以下基于 7.0 源码讨论。</p><h3 id="startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？"><a href="#startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？" class="headerlink" title="startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？"></a>startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote><p>用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。</p></blockquote><h4 id="requestCode"><a href="#requestCode" class="headerlink" title="requestCode"></a>requestCode</h4><blockquote><p>解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。</p><p>该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。</p><p>为什么 requestCode &lt; 0 时收不到结果？</p><ul><li><p>ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空// <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/core/ja…</a></p><pre><code> if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) {    // 只有非负数时新的 ActivityRecord 对象的 resultTo 变量才    指向发起者 ActivityRecord 对象    resultRecord = sourceRecord;}</code></pre><ul><li>在 ActivityStack 收到 finishActivityResultsLocked 时，读取ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量。</li></ul></li></ul><ul><li>在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了</li></ul></blockquote><h4 id="resultCode"><a href="#resultCode" class="headerlink" title="resultCode"></a>resultCode</h4><blockquote><p>异步调用结果码，告诉调用者成功/失败/其它信息</p><p>该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity</p></blockquote><h3 id="A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？"><a href="#A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？" class="headerlink" title="A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？"></a>A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？</h3><blockquote><p>setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中:</p><ul><li>最早 Activity 构造器阶段</li><li><p>最晚 Activity.finalize 内存回收阶段</p><pre><code>  // Home 键 + 不保留后台 Activity 可触发 onDestroy@Overrideprotected void onDestroy() {    super.onDestroy();    Log.d(TAG, &quot;onDestroy() called&quot;);    new ReqGC().start();}@Overrideprotected void finalize() throws Throwable {    Log.d(TAG, &quot;finalize() called&quot;);    finish();    super.finalize();}@Overridepublic void finish() {    Log.d(TAG, &quot;finish() called&quot;);    setResult(RESULT_OK, new Intent().putExtra(&quot;key&quot;,             &quot;resultData&quot;));    super.finish();}// 不泄漏 Activity 对象static class ReqGC {     public void start() {        final Handler handler = new Handler();        handler.postDelayed(new Runnable() {            @Override            public void run() {                System.gc();                handler.postDelayed(this, 10);            }        }, 10);    }}</code></pre></li></ul><p>setResult不可以位于finish之后</p><ul><li>如果位于finish之后执行，那信息无法传递给源 Activity</li><li>从代码可以看出setResult和finish类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据。</li></ul></blockquote><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><blockquote><ul><li><p>Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护</p></li><li><p>支持后台线程和 UI 线程分别进行 setResult 和 finish</p></li><li><p>但是为什么需要加锁保护这两个信息？需要「解决什么问题」？</p></li></ul></blockquote><h4 id="API-设计-数据组装问题"><a href="#API-设计-数据组装问题" class="headerlink" title="API 设计/数据组装问题"></a>API 设计/数据组装问题</h4><blockquote><ul><li><p>底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？</p></li><li><p>使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息</p></li></ul></blockquote><h3 id="API-内部原理-数据处理流程"><a href="#API-内部原理-数据处理流程" class="headerlink" title="API 内部原理/数据处理流程"></a>API 内部原理/数据处理流程</h3><blockquote><p><a href="http://upload-images.jianshu.io/upload_images/6575830-cd7aada2f45de461.png" target="_blank" rel="noopener">链接：6575830-cd7aada2f45de461.png (PNG Image, 3632 × 34…</a></p><p>关键节点：</p><ul><li>Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体</li><li>AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中</li><li>AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时</li><li>AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity</li><li>Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity</li></ul></blockquote><h3 id="startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题"><a href="#startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题" class="headerlink" title="startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题"></a>startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题</h3><blockquote><ul><li><p>基本原则:源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据</p></li><li><p>Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调</p><p> <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/core/ja…</a></p></li><li><p>Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调</p><p> <a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/java/co…</a></p></li><li><p>通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解startActivityForResult&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;startActivityForResul
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动模式</title>
    <link href="http://yoursite.com/2018/02/02/activity-start/"/>
    <id>http://yoursite.com/2018/02/02/activity-start/</id>
    <published>2018-02-02T06:10:52.571Z</published>
    <updated>2018-02-02T07:44:45.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解Activity的启动模式</p><ol><li><p>Activity的启动模式有哪几种，分别用于什么场景？</p></li><li><p>清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</p></li></ol><h3 id="Activity的启动模式有哪几种，分别用于什么场景？"><a href="#Activity的启动模式有哪几种，分别用于什么场景？" class="headerlink" title="Activity的启动模式有哪几种，分别用于什么场景？"></a>Activity的启动模式有哪几种，分别用于什么场景？</h3><ul><li>standard: 标准模式</li></ul><blockquote><p>系统的默认模式。一种多实例模式，每次启动一个Activity都会重新创建一个新的实例。被启动的Activit会被放入启动者的栈中，如果启动者是除Activity之外的Context，如Application，此时没有任务栈，就会报错，<br>此时需指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。没有特殊需求都默认是这种模式。</p></blockquote><ul><li>singleTop: 栈顶复用模式</li></ul><blockquote><p>如果一个Activity的实例已经在栈顶存在，启动这个Activity时，不会创建新的Activity，而是回调onNewIntent方法，如果不是在栈顶存在，则创建一个新的实例。<br>适合接收通知启动的内容显示页面，当接收到多条新闻推送时，用户展示新闻的Activity设置成此模式，根据传过来的intent数据显示不同的新闻信息，不会起动多个activity。</p></blockquote><ul><li>singleTask: 栈内复用模式</li></ul><blockquote><p>一种单实例模式，只要Activity的实例在一个栈中存在，再一次启动Activity时都不会重新创建实例，只回调onNewIntent方法，并从栈中清空这个Activity实例上的所有Activity实例。<br>适合作为程序的入口点，例如浏览器的主页面，不管多少应用启动浏览器，只会启动主页面一次，其余情况都只回调onNewIntent方法，并且会清空主页面上的其他页面。</p></blockquote><ul><li>singleInstance: 单实例模式</li></ul><blockquote><p>具有singleTask的所有特性，设置此模式的Activity只能单独存在在一个任务栈中。</p><p>一个例子：闹铃响铃页面，你在16点设置了一个闹钟，在15点58的时候，你启动了闹钟设置页面，并按home键返回桌面，在15点59的时候你打开微信和朋友聊天，16点的时候闹钟响了，并且弹出一个对话框形式的Activity （AlarmAlertActivity，这个Activity是以singleInstance模式打开的）提示你16点到了，这时候你按返回键，返回的是微信聊天页，不是闹钟设置页面，因为AlarmAlertActivity以singleInstance模式打开，栈里只有它一个实例，退出后这个任务栈空了，如果以singleTask打开，这时候返回的是闹钟设置页面。</p></blockquote><h3 id="清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"><a href="#清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？" class="headerlink" title="清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"></a>清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</h3><h4 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h4><blockquote><p>在singleTop、singleTask、singleInstance模式下再次启动相同的Activity，如果期望只有一个实例存在，再次启动就会调用onNewIntent，在onNewIntent中可以通过调用setIntents刷新Intent数据</p></blockquote><h4 id="onConfigurationChanged"><a href="#onConfigurationChanged" class="headerlink" title="onConfigurationChanged"></a>onConfigurationChanged</h4><blockquote><p>当Android设置正在运行app时，如果设备的语言，屏幕方向，键盘的参数改变了，默认会销毁当前Activity并重新创建一次Activity来重新加载新的配置信息。为了防止系统销毁，可以再<code>AndroidManifest.xml</code>文件中给Activity设置<code>android:configChanges</code>属性，可选值有<code>[&quot;mcc&quot;,&quot;mnc&quot;,&quot;locale&quot;,&quot;touchscreen&quot;,&quot;keyboard&quot;,&quot;keyboardHidden&quot;,&quot;navigation&quot;,&quot;screenLayout&quot;,&quot;fontScale&quot;,&quot;uiMode&quot;,&quot;orientation&quot;,&quot;density&quot;,&quot;screenSize&quot;,&quot;smallestScreenSize&quot;]</code>，申明的配置发生改变时，将不会重启Activity，而是回调onConfigurationChanged方法。如果设置的属性是<code>orientation</code>，当屏幕方向发生变化的时候，会阻止系统销毁Activity重新创建，而是保持运行，回调onConfigurationChanged方法，我们需要在onConfigurationChanged中做屏幕方向发生改变的操作，onConfigurationChanged会传递一个Configuration对象，通过读取这个对象的配置信息，来自行适配新的UI页面。</p></blockquote><pre><code>注：从Android 3.2(API 13)开始，当设备屏幕方向发生变化的时候，screenSize也会发生变化，因此需要设置android:configChanges=&quot;orientation|screenSize&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解Activity的启动模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Activity的启动模式有哪几种，分别用于什么场景？&lt;/p
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解Service</title>
    <link href="http://yoursite.com/2018/02/01/android-service/"/>
    <id>http://yoursite.com/2018/02/01/android-service/</id>
    <published>2018-02-01T13:53:44.006Z</published>
    <updated>2018-02-02T07:52:23.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>清晰地理解Service。</p><ul><li><p>Service的start和bind状态有什么区别？</p></li><li><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></li><li><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></li><li><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></li></ul><blockquote><p>Service的start和bind状态有什么区别：</p></blockquote><p> start启动的service，service有独立的生命周期，不依赖该组件；</p><p> 多次调用start方法，会重复调用onStartCommand方法；</p><p> start启动的service，必须调用stopService或者stopSelfl来停止service（IntentService会自动调用stopSelf方法）；</p><p> 多次调用bind方法，只会调用一次onBind方法，bind绑定的service，service依赖这些组件，这些组件全部销毁后，service也会一起销毁。</p><blockquote><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></blockquote><p>不论被start多少次，只需要stopService或者stopSelf一次；</p><p>调用n次bindService只需要调用一次unBindService；</p><p>所以，需要调用一次stopService（或者stopSelf）和一次unBindService方法，执行顺序没有要求，最后一个stopService（stopSelf）或者unBindService会导致Service执行onDestory方法。</p><blockquote><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></blockquote><p>一共有如下4种返回值：</p><pre><code>/**为了兼容版本，在Service被杀死后,并不保证onStartCommand会被再一次调用*/public static final int START_STICKY_COMPATIBILITY = 0;/**Service被杀死后，保留启动状态，但是不保存intent，之后系统会尝试重启Service，并重新回调onStartCommand方法，如果接下来没有其他start命令，intent会为空，因此要注意onStartCommand对intent的非空判断*/public static final int START_STICKY = 1;/**常规操作，除非在Service被杀死前还有组件调用startService,否则系统不会保留启动状态并重启该Service*/public static final int START_NOT_STICKY = 2;/**Service被杀死后，系统会组织一次Service的重启（除非在那之前调用了stopSelf方法），被杀死前最后一次传递的intent将重新执行，该flag不会传递空的intent。*/public static final int START_REDELIVER_INTENT = 3;</code></pre><blockquote><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></blockquote><p>Service默认是运行在主线程的，其生命周期方法也是运行在主线程：</p><p><img src="/2018/02/01/android-service/android-service.png" alt="service"></p><p>因此，如果要在Service中进行耗时操作，必须另起线程，或者用IntentService，否则很容易引起ANR。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;清晰地理解Service。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Service的start和bind状态有什么区别？&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解Java中的synchronized关键字</title>
    <link href="http://yoursite.com/2018/02/01/java-sunc/"/>
    <id>http://yoursite.com/2018/02/01/java-sunc/</id>
    <published>2018-02-01T13:40:42.542Z</published>
    <updated>2018-02-01T13:48:08.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。</p><p>有如下一个类A</p><pre><code>class A {    public synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><p>然后创建两个对象</p><pre><code>A a1 = new A();A a2 = new A();</code></pre><p>然后在两个线程中并发访问如下代码：</p><pre><code>Thread a1.a();Thread a2.a();public class Test {    public static void main(String[] args) {        A a1 = new A();        A a2 = new A();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a1.a();            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a2.a();            }        }).start();    }}</code></pre><p>请问二者能否构成线程同步？</p><p>如果A的定义是下面这种呢？</p><pre><code>class A {    public static synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public static synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>没有加static的时候结果是这样的:</p><p><img src="/2018/02/01/java-sunc/sync.jpg" alt="sync"></p><p>加了static的时候结果是这样的:</p><p><img src="/2018/02/01/java-sunc/sync1.jpg" alt="sync1"></p><p>可以看出，没有static时不能同步，有static时能同步。</p><p>Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。</p><p>Synchronized主修修饰对象为以下三种：</p><ol><li><p>修饰普通方法：一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象，如果多个线程不同对象访问该方法，则无法保证同步。</p></li><li><p>修饰静态方法：由于静态方法是类方法，所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</p></li><li><p>修饰代码块：其中普通代码块，如Synchronized（obj），这里的obj，可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p></li></ol><p>Synchronized方法控制范围较大，它会同步对象中所有Synchronized方法的代码。</p><p>Synchronized代码块控制范围较小，它只会同步代码块中的代码，而位于代码块之外的代码是可以被多个线程访问的。</p><p>简单来说 就是 Synchronized代码块更加灵活精确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/01/30/hello-world/"/>
    <id>http://yoursite.com/2018/01/30/hello-world/</id>
    <published>2018-01-30T08:56:01.913Z</published>
    <updated>2018-02-01T07:45:36.256Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo笔记" scheme="http://yoursite.com/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
