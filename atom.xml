<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝调华尔兹</title>
  
  <subtitle>每个人都曾经穿越不为人知的黑暗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-12T12:59:28.032Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YU.LIAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity实践技巧</title>
    <link href="http://yoursite.com/2018/03/11/activity-%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/03/11/activity-实践技巧/</id>
    <published>2018-03-11T13:07:51.000Z</published>
    <updated>2018-03-12T12:59:28.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Activity的一些实践技巧"><a href="#关于Activity的一些实践技巧" class="headerlink" title="关于Activity的一些实践技巧"></a>关于Activity的一些实践技巧</h2><h4 id="1、知道当前是在哪一个Activity"><a href="#1、知道当前是在哪一个Activity" class="headerlink" title="1、知道当前是在哪一个Activity"></a>1、知道当前是在哪一个Activity</h4><p>可以在所有Activity的父类（基类）的<code>onCreate()</code>中调用<code>getClass().getSimpleName()</code>方法获取当前实例的类名并打印出来，如下：</p><pre><code>protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main2);    Log.i(&quot;MainActivity2&quot;,&quot;oncreate&quot;+getClass().getSimpleName());        }    });}</code></pre><p>这样，当我们进入一个Activity时，改Activity的类名就会打印出来，我们可以随时知道我们当前页面对应哪一个Activity。</p><h4 id="2、随时随地退出程序"><a href="#2、随时随地退出程序" class="headerlink" title="2、随时随地退出程序"></a>2、随时随地退出程序</h4><p>当你当前Activity所在任务栈中实例很多事，想退出程序是很不方便的事情，需要按很多次back键，按home键只是挂起，并没有退出。要解决这个问题，只需要一个专门的集合类对所有的Activity进行管理就可以了，例如：</p><p>新建一个ActivityCollector类作为Activity的管理类。</p><pre><code>public class ActivityCollector {    public static List&lt;Activity&gt; mActivities = new ArrayList&lt;&gt;();    public static void addActivity(Activity activity){        mActivities.add(activity);    }    public static void removeActivity(Activity activity){        mActivities.remove(activity);    }    public static void finishAll(){        for (Activity activity:mActivities){            if(!activity.isFinishing()){                activity.finish();            }        }    }}</code></pre><p>可以在所有Activity的父类（基类）的<code>onCreate()</code>中调用<code>ActivityCollector. addActivity(this)</code>，在<code>onDestroy()</code>中调用<code>ActivityCollector. removeActivity(this)</code>，如果要直接退出程序，可以调用<code>ActivityCollector. finishAll()</code>，还可以在销毁所有Activity后调用<code>android.os.Process.killProcess(android.os.Process.myPid())</code></p><p><code>killProcess()</code>的作用是杀掉一个进程，参数为一个进程id，我们通过<code>myPid()</code>来获取当前程序的进程id，需要注意的是，这个方法只能用于杀掉当前程序的进程，不能用这个方法杀死其他程序的进程。</p><h4 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h4><p>启动活动的方法大家都很熟悉，首先通过Intent构建意图，然后调用startActivity()或者startActivityForResult()方法将活动启动起来，如果有数据从一个活动到另一个活动，也可以借助Intent来完成。</p><p>假设Main2Activity中需要用到两个重要的参数，在启动Main2Activity的时候必须要传递过来，那么，我们很容易写成下面这个代码：</p><pre><code>Intent intent = new Intent(this,Main2Activity.class);intent.putExtra(&quot;param1&quot;,&quot;param1&quot;);intent.putExtra(&quot;param2&quot;,&quot;param2&quot;);startActivity(intent);</code></pre><p>这样写本身没有什么问题，但是在实际开发中会给其他同事造成困扰，换一种写法，在MAin2Activity中增加一个<code>actionStart()</code>方法:</p><pre><code>public static void actionStart(Context context,String param1,String param2){    Intent intent = new Intent(context,Main2Activity.class);    intent.putExtra(&quot;param1&quot;,&quot;param1&quot;);    intent.putExtra(&quot;param2&quot;,&quot;param2&quot;);    context.startActivity(intent);}</code></pre><p>在要启动Main2Activity的地方调用这个方法：</p><pre><code>Main2Activity.actionStart(this,&quot;param1&quot;,&quot;param2&quot;);</code></pre><p>这样写就一目了然了，启动Main2Activity所需要的参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于Activity的一些实践技巧&quot;&gt;&lt;a href=&quot;#关于Activity的一些实践技巧&quot; class=&quot;headerlink&quot; title=&quot;关于Activity的一些实践技巧&quot;&gt;&lt;/a&gt;关于Activity的一些实践技巧&lt;/h2&gt;&lt;h4 id=&quot;1、知道当
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>关于Intent</title>
    <link href="http://yoursite.com/2018/03/11/anout-intent/"/>
    <id>http://yoursite.com/2018/03/11/anout-intent/</id>
    <published>2018-03-11T05:41:13.692Z</published>
    <updated>2018-03-11T08:08:26.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>学习Intent相关知识。</p><p>Intent是Android程序中各个组件之间进行交互的一种重要方式。</p><p>Intent大致可以分为两种：<strong>显式Intent</strong> 和 <strong>隐式Intent</strong></p><h3 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h3><p>Intent有很多构造方法，其中一个是：</p><p><code>Intent(Context packageContext, Class&lt;?&gt; cls)</code></p><p>packageContext为启动活动的上下文，cls为想要启动的目标活动。</p><p>Activity提供了一个<code>StartActiviy(Intent intent)</code>方法，执行如下代码：</p><pre><code>Intent intent = new Intent(this,Main2Activity.class);startActivity(intent);</code></pre><p>就可以启动一个新的Activity了，使用这种方式来启动活动，Intent的“意图”就很明显了，因此我们成为显式Intent。</p><h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>相较于显式Intent，隐式Intent含蓄很多，并不明确指定想要启动哪一个活动，而是指定一系列更为抽象的action和category等信息，由系统去寻找合适的活动去启动。合适的活动简单说就是可以响应这个隐式Intent的活动。</p><p>在<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动可以响应的action和category。例如:</p><pre><code>&lt;activity android:name=&quot;.Main2Activity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;liao.yu.test.Main2Activity.Start&quot;/&gt;        &lt;category android:name=&quot;liao.yu.test.Main2Activity.Mycate&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>在action标签中指定了liao.yu.test.Main2Activity.Start这个action，而category标签中包含一些附加信息，更加明确指明了当前活动能够响应的Intent中还有可能带有的category，只用action和category同时匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</p><pre><code>Intent intent = new Intent(&quot;liao.yu.test.Main2Activity.Start&quot;);intent.addCategory(&quot;liao.yu.test.Main2Activity.Mycate&quot;);startActivity(intent);</code></pre><h3 id="更多隐式Intent"><a href="#更多隐式Intent" class="headerlink" title="更多隐式Intent"></a>更多隐式Intent</h3><p>使用隐式Intent，不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这样可以实现Android多个程序之间共享功能。</p><p>打开系统浏览器</p><pre><code>Intent intent = new Intent(Intent.ACTION_VIEW);intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));startActivity(intent);</code></pre><p>Intent.ACTION_VIEW为Android系统的内置动作。</p><p>我们还能在<code>&lt;intent-filter&gt;</code>再配置一个<code>&lt;data&gt;</code>标签，用于更加精确的指定当前活动能够响应什么类型的数据。<data>标签中主要可以配置下面这些内容：</data></p><blockquote><blockquote><ul><li>android:scheme。用于指定数据的协议部分，如上例中的http 部分。</li><li>android:host。用于指定数据的主机名部分，如上例中的www.baidu.com部分。</li><li>android:port。用于指定数据的端口部分，一般紧随在主机名之后。</li><li>android:path。用于指定主机名和端口后面的部分，如一段网址中跟在域名后面的内容。</li><li>android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ul></blockquote></blockquote><p>只有<code>&lt;data&gt;</code>标签中内容和Intent中携带的Data完全一致的时候，当前活动才能够响应该Intent。不过<code>&lt;data&gt;</code>标签中不会指定太多的内容。上例中只需要指定android:scheme为http，就可以响应http协议的Intent了。</p><pre><code>&lt;activity android:name=&quot;.Main2Activity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name=&quot;liao.yu.test.Main2Activity.Start&quot;/&gt;        &lt;category android:name=&quot;liao.yu.test.Main2Activity.Mycate&quot;/&gt;        &lt;data android:scheme=&quot;http&quot;/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>除了http协议外，还可以指定其他协议，geo表示地理位置，tel表示打电话等。</p><pre><code>Intent intent = new Intent(Intent.ACTION_DIAL);intent.setData(Uri.parse(&quot;tel:10086&quot;));startActivity(intent);</code></pre><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>在启动活动时传递数据的思路很简单，Intent提供了一系列putExtra()方法可以重载，将数据暂存在Intent中，启动另一个活动后取出</p><p>在上一个活动中：</p><pre><code>String data = &quot;test&quot;;Intent intent = new Intent(this,Main2Activity.class);intent.putExtra(&quot;data&quot;,data);startActivity(intent);</code></pre><p>在第二个活动中：</p><pre><code>Intent intent = getIntent();String data = intent.getStringExtra(&quot;data&quot;);Log.i(&quot;data&quot;,data);</code></pre><p>不同的数据类型调用不同的get方法。</p><h3 id="返回数据给上一个活"><a href="#返回数据给上一个活" class="headerlink" title="返回数据给上一个活"></a>返回数据给上一个活</h3><p>Activity有<code>startActivityForResult(Intent intent, int requestCode)</code>方法用于期望返回值的启动活动。</p><p>requestCode为请求码，用于回调中判断数据来源。</p><p>第一个活动中：</p><pre><code>Intent intent = new Intent(this,Main2Activity.class);startActivityForResult(intent,11);</code></pre><p>第二个活动中：</p><pre><code>Intent intent = new Intent();intent.putExtra(&quot;data&quot;,&quot;data&quot;);setResult(RESULT_OK,intent);finish();</code></pre><p>返回第一个活动时，会调用<code>onActivityResult(int requestCode, int resultCode, Intent data)</code>方法：</p><pre><code>protected void onActivityResult(int requestCode, int resultCode,Intent data) {    super.onActivityResult(requestCode, resultCode, data);    if(resultCode == RESULT_OK){        switch (requestCode){            case 11:                String str = data.getStringExtra(&quot;data&quot;);                Log.i(&quot;data&quot;,str);                break;        }    }}</code></pre><p>requestCode为请求码，resultCode为结果码，data为返回的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;学习Intent相关知识。&lt;/p&gt;
&lt;p&gt;Intent是Android程序中各个组件之间进行交互的一种重要方式。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio项目中build.gradle文件(1)</title>
    <link href="http://yoursite.com/2018/02/10/build-gradle/"/>
    <id>http://yoursite.com/2018/02/10/build-gradle/</id>
    <published>2018-02-10T07:23:12.000Z</published>
    <updated>2018-02-24T13:28:59.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>了解AndroidStudio（以下简称AS）项目中build.gradle文件。</p><p>每个新建AS项目中会有两个build.gradle文件，最外层目录有一个，然后app目录下会包含一个。</p><p>最外层目录下的build.gradle文件代码如下：</p><pre><code>buildscript{    respositories{        jcenter()    }    dependencies {       classpath &apos;com.android.tools.build:gradle:2.2.3&apos;    }}allprojects{    repositories {        jcenter()  }}</code></pre><p>这些代码都是自动生成的。然我们看关键部分：</p><p>两处respositories闭包都声明了jcenter()配置，JCenter是由JFrog公司提供的Bintray中的Java仓库。它是当前世界上最大的Java和Android开源软件构件仓库。所有内容都通过内容分发网络（CDN）使用加密https连接获取。JCenter是Goovy Grape内的默认仓库，Gradle内建支持（jcenter()仓库），非常易于在（除了Maven之外的）其他构建工具内进行配置。</p><p>dependencies闭包中使用classpath声明了一个gradle插件，因为gradle不是专门为Android项目开发的，C++、Java等很多项目都能用gradle构建，因此，要使用gradle构建Android项目，需要声明gradle的Android插件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;p&gt;了解AndroidStudio（以下简称AS）项目中build.gradle文件。&lt;/p&gt;
&lt;p&gt;每个新建AS项目中会有两个
      
    
    </summary>
    
      <category term="gradle学习" scheme="http://yoursite.com/categories/gradle%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="gradle" scheme="http://yoursite.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android学习路线</title>
    <link href="http://yoursite.com/2018/02/10/android-study/"/>
    <id>http://yoursite.com/2018/02/10/android-study/</id>
    <published>2018-02-10T07:23:12.000Z</published>
    <updated>2018-02-10T07:38:41.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-学习路线终极指南"><a href="#Android-学习路线终极指南" class="headerlink" title="Android 学习路线终极指南"></a>Android 学习路线终极指南</h2><p>推荐一个学习方法给大家，你需要 三篇文章 + 三本书 + 一年时间。</p><h4 id="三篇文章"><a href="#三篇文章" class="headerlink" title="三篇文章"></a>三篇文章</h4><ul><li><a href="http://blog.csdn.net/singwhatiwanna/article/details/46810527" target="_blank" rel="noopener">链接-我对Android的理解</a></li><li><a href="http://blog.csdn.net/singwhatiwanna/article/details/42343847" target="_blank" rel="noopener">链接-Android学习路线：如何成长为高级工程师</a></li><li><a href="http://blog.csdn.net/singwhatiwanna/article/details/49560409" target="_blank" rel="noopener">链接-Android学习路线指南</a></li></ul><h4 id="三本书"><a href="#三本书" class="headerlink" title="三本书"></a>三本书</h4><p><code>《第一行代码 Android》、《Android开发艺术探索》、《Android源码设计模式解析与实战》</code></p><p>花一年时间把它们撸完就行。</p><p>“什么？你一年撸不完？”</p><p>那你回到高三的时代，按那个学习的强度来，一年时间三本书肯定可以撸完，相信我。</p><p>出名要趁早，提高技术也要趁早！</p><p>不管是学习任何技术，下面几句话都通用：</p><ul><li>要梳理知识，对知识建立起体系化的感觉</li><li>好奇心，要知其所以然</li><li>在最短的时间去实践</li></ul><p><strong>最后，给大家送句话，不是鸡汤，是真理：<br>别人光鲜的背后，总有着鲜为人知的苦楚。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android-学习路线终极指南&quot;&gt;&lt;a href=&quot;#Android-学习路线终极指南&quot; class=&quot;headerlink&quot; title=&quot;Android 学习路线终极指南&quot;&gt;&lt;/a&gt;Android 学习路线终极指南&lt;/h2&gt;&lt;p&gt;推荐一个学习方法给大家，你需
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Java基础知识复习</title>
    <link href="http://yoursite.com/2018/02/06/andriod-eight/"/>
    <id>http://yoursite.com/2018/02/06/andriod-eight/</id>
    <published>2018-02-06T07:15:09.436Z</published>
    <updated>2018-02-07T02:06:26.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>复习Java基础知识</p><ol><li>Java中有哪几种引用？它们的含义和区别是什么？</li><li>请用Java实现一个线程安全且高效的单例模式。</li></ol><h3 id="Java中有哪几种引用？它们的含义和区别是什么？"><a href="#Java中有哪几种引用？它们的含义和区别是什么？" class="headerlink" title="Java中有哪几种引用？它们的含义和区别是什么？"></a>Java中有哪几种引用？它们的含义和区别是什么？</h3><p><strong>Java中有哪几种引用：</strong></p><ul><li><p>强应用(StrongReference)</p><p>  强引用在程序之间普遍存在的，类似于<code>Object obj = new Object()</code>这类引用。只要强引用还存在，垃圾回收器就永远不会回收持被强引用关联的对象，如果想中断强引用和某个对象之间的关系，可以将引用赋值为null。</p></li><li><p>软引用(SoftReference)</p><p>  软引用用来描述一些还有用，单并非必须的对象，对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行回收，如果此次回收还没有足够的内存，才会抛出内存溢出异常。</p><pre><code>String str = new String(&quot;abc&quot;);//强引用SoftReference&lt;String&gt; strRef = new SoftReference&lt;String&gt;(str);//软引用</code></pre><p>  当内存不足时，等价于：</p><pre><code>if(JVM.内存不足){    str = null;//转换为软引用    System.gc();//垃圾回收器进行回收}</code></pre></li><li><p>弱引用(WeakReference)</p><p>  弱引用也是用来描述非必须对象的，它的强度比软引用还要弱一些，被弱引用关联的对象，只能生存到下一次垃圾回收之前，当垃圾回收器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。</p><pre><code>String str = new String(&quot;str&quot;);WeakReference&lt;String&gt; weakRef = new WeakReference&lt;String&gt;(str);</code></pre><p>  当垃圾回收器扫描回收时等价于:</p><pre><code>str = null;System.gc();</code></pre></li><li><p>虚引用(PhantomReference)</p><p>  “虚引用”顾名思义，就是形容虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象只持有虚引用，那么它就和没有任何引用一样，在任何时候都有可能会被垃圾回收器回收。</p><p>  虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用与软引用和弱引用的一个区别在于，虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象的时候，如果发现它还有虚引用，就会在回收这个对象之前，把这个虚引用加入到与之关联的引用队列中。</p></li></ul><h3 id="请用Java实现一个线程安全且高效的单例模式"><a href="#请用Java实现一个线程安全且高效的单例模式" class="headerlink" title="请用Java实现一个线程安全且高效的单例模式"></a>请用Java实现一个线程安全且高效的单例模式</h3><ol><li><p>利用类加载机制来保证只创建一个instance实例，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</p><p> 但是有两点需要注意：</p><ul><li>可能有人利用反射强制调用我们的私有构造器</li><li><p>都需要额外的<code>Serializable、transient、readResolve()</code>来实现序列化，否则每次反序列化一个序列化实例都会创建一个新的实例。</p><pre><code>public class Singleton{    private Singleton(){}    public static Singleton getInstance(){        return SingletonHolder.sInstance;    }    /**静态内部类*/    public static class SingletonHolder{        private final Singleton sInstance = new Singleton();    }}  </code></pre></li></ul></li></ol><ol><li><p>使用DCL，保证序列化和反序列化安全，延迟加载，线程安全，防反射</p><pre><code>public    class MySingleton implements Serializable{    private static final long serialVersionUID = 234234141414L;    private static volatile MySingleton singleton;    private static boolean isFirst = true;    private MySingleton(){        if(isFirst){            isFirst = false;        }else{            throw new RuntimeException(&quot;破坏了单例，第二个实例创建失败&quot;);        }    }    public static MySingleton getInstance(){        if(sigleton == null){            synchronized(MySingleton.class){                if(single == null){                    singleton = new MySingleton();                }            }        }        return singleton;    }    private Object readResolved(){        return singleton;    }}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;复习Java基础知识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中有哪几种引用？它们的含义和区别是什么？&lt;/li&gt;
&lt;li&gt;请用Ja
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>关于序列化</title>
    <link href="http://yoursite.com/2018/02/06/serialization/"/>
    <id>http://yoursite.com/2018/02/06/serialization/</id>
    <published>2018-02-06T03:18:41.000Z</published>
    <updated>2018-02-06T06:42:35.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>关于序列化的知识</p><ol><li><p>Parcelable和Serializable有什么用，它们有什么差别？</p></li><li><p>自定义一个类让其实现Parcelable，大致流程是什么?</p></li></ol><h3 id="Parcelable和Serializable有什么用，它们有什么差别？"><a href="#Parcelable和Serializable有什么用，它们有什么差别？" class="headerlink" title="Parcelable和Serializable有什么用，它们有什么差别？"></a>Parcelable和Serializable有什么用，它们有什么差别？</h3><p>Parcelable和Serializable都可以实现序列化，使对象可以变成二进制流在内存中传输数据。在Android中，只要实现了二者之一的类就可以使用Intent和Binder来传递数据。实现了Parcelable接口的类依赖Parcel这个类来实现数据的传递，它并不是一个一般用途的序列化机制，主要用于IPC机制的高性能传输。</p><p>差别：</p><blockquote><ol><li>从来源上看：Parcelable是Android中提供的序列化接口，Serializable是Java提供的序列化接口。因此Parcelable只能在Android中使用，而Serializable可以在任何使用Java语言的地方使用。</li><li><p>从使用上看，Parcelable使用的比较麻烦，序列化过程需要实现Parcelable的<code>writetoParcel(Parcel dest,int flags)</code>方法和<code>describeContents()</code>方法。为了反序列化，还需要提供一个叫做CREATOR的非空静态字段，该字段类型是实现了Parcel.Creator接口的类，一般用一个匿名内部类实现就可以了。有一些插件可以方便实现Parcelable接口。</p><p> Serializable的使用比较简单，直接实现Serializable接口就行了，该接口没有任何方法，序列化机制是提供一个long型的serialVersionUID，如果没有显示的指定，该序列化运行时，会基于该类的结构自动计算一个值。如果该类的结构发生变化，就会导致自动计算的serialVersionUID不同。这样会导致一个问题，序列化之后类如果新增了一个字段，反序列过程就会失败，一般会报InvaliClassException这样的异常，如：<br><img src="/2018/02/06/serialization/invalidexceprion.png" alt="invalidException"><br>如果显示的指定了serialVersionUID，只要类的结果不发生重大变化，如更改类型，字段类型发生变化等，只添加或者删除字段等都是可以反序列化成功的。</p></li><li><p>从效率上看，Serializable的序列化和反序列化需要使用到IO操作，而Parcelable不需要，所以Parcelable的效率要高于Serializable，Android中推荐Parcelable。</p></li></ol></blockquote><p><strong>注意：如果需要将对象持久化到存储设备或者通过网络传输到其他设备，最好使用Serializable。</strong></p><h3 id="自定义一个类让其实现Parcelable，大致流程是什么"><a href="#自定义一个类让其实现Parcelable，大致流程是什么" class="headerlink" title="自定义一个类让其实现Parcelable，大致流程是什么?"></a>自定义一个类让其实现Parcelable，大致流程是什么?</h3><p>自定义一个类让其实现Parcelable，大致流程是先实现该接口的<code>writetoParcel(Parcel dest,int flags)</code>方法和<code>describeContents()</code>方法，然后添加一个Parcel.Creator类型的名为CREATOR的非空静态字段。该类中字段如果有其他的自定义类型，其它的自定义类型也需要实现Parcelable或者Serializable接口。例如：<br><img src="/2018/02/06/serialization/liucheng.png" alt="invalidException"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;关于序列化的知识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Parcelable和Serializable有什么用，它们有什么差别？&lt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>关于View</title>
    <link href="http://yoursite.com/2018/02/02/android-view/"/>
    <id>http://yoursite.com/2018/02/02/android-view/</id>
    <published>2018-02-02T08:52:37.000Z</published>
    <updated>2018-02-02T15:07:55.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>学习关于View的知识</p><ol><li>View的getWidth()和getMeasuredWidth()有什么区别吗？</li><li>如何在onCreate中拿到View的宽度和高度？</li></ol><h3 id="View的getWidth-和getMeasuredWidth-有什么区别吗？"><a href="#View的getWidth-和getMeasuredWidth-有什么区别吗？" class="headerlink" title="View的getWidth()和getMeasuredWidth()有什么区别吗？"></a>View的getWidth()和getMeasuredWidth()有什么区别吗？</h3><blockquote><p>View的宽高是由View本身和parent容器共同决定的。</p><p>getMeasuredWidth()和getWidth()分别对应View的measure与layout阶段，getMeasuredWidth()(int widthMeasureSpec,int heightMeasureSpec)方法中获得，getWidth()是在onLayout后获得。大部分情况下他们是一样的，也有一些不相同的情况，例如，在父View的onLayout中或者在View本身的onDraw方法中调用measure(0,0)(其中参数0可以自己设置)方法，两者的结果可能会不同。</p></blockquote><p>getWidth()源码：</p><p><img src="/2018/02/02/android-view/getWidth.png" alt="getWidth"></p><blockquote><p>可以看出，getWidth()返回的是右边的坐标减去左边的坐标，这是要在布局以后才能确定的，也就是说要在onLayout后才能得到，所以getWidth()是在View设定好布局后整个View的宽度。</p></blockquote><p>getMeasuredWidth()源码:</p><p><img src="/2018/02/02/android-view/getMeasureWidth.png" alt="getMeasureWidth"></p><blockquote><p>可以看出getMeasuredWidth返回的是原始测量宽度，所以getMeasuredWidth是对View内容进行测量后得到View内容占据的宽度。</p><p>在fuView的onLayout中或者在View本身的onDraw方法中调用measure(0,0)(其中参数0可以自己设置)方法时，如下:</p></blockquote><p><img src="/2018/02/02/android-view/testActivity.png" alt="testActivity"></p><p><img src="/2018/02/02/android-view/testXml.png" alt="testXml"><br>此时的打印结果为:<br><img src="/2018/02/02/android-view/testResult.png" alt="testResult"></p><blockquote><p>所以可以得出结论:getWidth()是View设定好布局后整个View的宽度，getMeasureWidth()是对View上的内容进行测量后得到的View内容的宽度。</p></blockquote><h3 id="如何在onCreate中拿到View的宽度和高度？"><a href="#如何在onCreate中拿到View的宽度和高度？" class="headerlink" title="如何在onCreate中拿到View的宽度和高度？"></a>如何在onCreate中拿到View的宽度和高度？</h3><blockquote><p>onCreate中获取View的宽高有3中方式</p><p>我们先定义一个获取View宽高的方法:</p></blockquote><p><img src="/2018/02/02/android-view/getWH.png" alt="getWH"></p><ul><li><p>View.post(Runnable runnable)</p><p>  利用View的通信机制，发送一个message到Message queue中，当View layout处理完成时，自动发送消息，通知UI线程，取巧的获取View的宽高，代码简洁，使用简单，相对比ViewTreeObserver监听处理，还不需要手动移除观察者监听事件。</p></li></ul><p><img src="/2018/02/02/android-view/runnable.png" alt="runnable"><br>此时打印结果：<br><img src="/2018/02/02/android-view/runnableResult.png" alt="runnableResult"></p><ul><li><p>ViewTreeObserver.addGloblLayoutListener(OnGlobalLayoutListener listener)</p><p>  监听View的onLayout绘制过程，一旦layout发生变化，立即回调onLayoutChange方法。<br><img src="/2018/02/02/android-view/treeGlobal.png" alt="treeGlobal"><br>此时打印结果:<br><img src="/2018/02/02/android-view/treeGlobalResult.png" alt="treeGlobalRresult"></p></li></ul><blockquote><p>   注意：使用完后要调用removeOnGlobalLayoutListener方法移除监听事件，<br>   避免后续每一次发生全局View变化时都会回调这个事件，影响性能。</p></blockquote><ul><li><p>View.measure(int widthMeasureSpec,int heightMeaseureSpec)</p><pre><code>View.MeasureSpec.makeMeasureSpec(@IntRange(from = 0,to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,@MeasureSpecMode int mode)</code></pre><p>  其中，MeasureSpec.MODE_SHIFT = 30    </p><p>  size 的最大值为（1 &lt;&lt; 30）-1，即用30位二进制表示，最大为30个1(2^30 - 1);<br><img src="/2018/02/02/android-view/measure.png" alt="measure"><br>打印结果:<br><img src="/2018/02/02/android-view/measureResult.png" alt="measureResult"><br><img src="/2018/02/02/android-view/measure1.png" alt="measure1"><br>打印结果:<br><img src="/2018/02/02/android-view/measure1Result.png" alt="measure1Result"></p></li></ul><h3 id="除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged-boolean-hasFocus-中获取"><a href="#除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged-boolean-hasFocus-中获取" class="headerlink" title="除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged(boolean hasFocus)中获取"></a>除了在onCreate中获取View的宽高，还可以在Activity的onWindowFocusChanged(boolean hasFocus)中获取</h3><p>源码：<br><img src="/2018/02/02/android-view/focussource.png" alt="focussource"><br><img src="/2018/02/02/android-view/focus.png" alt="focus"><br>打印结果:<br><img src="/2018/02/02/android-view/focusResult.png" alt="focusResult"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;学习关于View的知识&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View的getWidth()和getMeasuredWidth()有什么
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>关于startActivityForResult</title>
    <link href="http://yoursite.com/2018/02/02/startactvityforresult/"/>
    <id>http://yoursite.com/2018/02/02/startactvityforresult/</id>
    <published>2018-02-02T08:12:25.000Z</published>
    <updated>2018-02-02T09:13:04.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解startActivityForResult</p><ol><li><p>startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？</p></li><li><p>Activity A启动B的时候，在B中何时该执行setResult ？setResult可以位于Activity的finish方法之后吗？</p></li></ol><p>注意以下基于 7.0 源码讨论。</p><h3 id="startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？"><a href="#startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？" class="headerlink" title="startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？"></a>startActivityForResult的使用场景是什么？onActivityResult回调里面的resultCode和requestCode含义是什么？</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote><p>用户开始新的活动，并且希望得到新活动的某些信息。比如选择照片、选择联系人、选择收货地址、进行某块数据编辑工作等。</p></blockquote><h4 id="requestCode"><a href="#requestCode" class="headerlink" title="requestCode"></a>requestCode</h4><blockquote><p>解决的是「区分多个异步任务」的问题。与其他异步 API 的设计类似，如果没有这个信息，那么 Activity 在收到响应时会进入混乱的状态。比如他不知道自己得到的是选择照片还是选择联系人的结果。</p><p>该信息会发送到 AMS 那边的 ActivityRecord.requestCode 变量进行记录，Client 端新 Activity 并不知道这个信息。</p><p>为什么 requestCode &lt; 0 时收不到结果？</p><ul><li><p>ActivityStarter 收到 startActivityLocked 时，写入ActivityRecord.resultTo 变量为空// <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#266" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/core/ja…</a></p><pre><code> if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) {    // 只有非负数时新的 ActivityRecord 对象的 resultTo 变量才    指向发起者 ActivityRecord 对象    resultRecord = sourceRecord;}</code></pre><ul><li>在 ActivityStack 收到 finishActivityResultsLocked 时，读取ActivityRecord.resultTo 变量为空，结果数据不会添加到源 ActivityRecord.results 变量。</li></ul></li></ul><ul><li>在 ActivityStack 收到 resumeTopActivityInnerLocked 时，读取 ActivityRecord.results 数组为空，不会分发结果数据，这样源 Activity 也就没有结果回调了</li></ul></blockquote><h4 id="resultCode"><a href="#resultCode" class="headerlink" title="resultCode"></a>resultCode</h4><blockquote><p>异步调用结果码，告诉调用者成功/失败/其它信息</p><p>该信息由被调用 Activity / framework 写入，并经过 AMS 传递给源 Activity</p></blockquote><h3 id="A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？"><a href="#A-启动-B-，B-中何时执行-setResult-setResult-是否可以位于-finish-之后？" class="headerlink" title="A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？"></a>A 启动 B ，B 中何时执行 setResult ? setResult 是否可以位于 finish 之后？</h3><blockquote><p>setResult 在 finish 之前执行，只是把数据记录在 Activity.mResultCode 和 Activity.mResultData 变量中:</p><ul><li>最早 Activity 构造器阶段</li><li><p>最晚 Activity.finalize 内存回收阶段</p><pre><code>  // Home 键 + 不保留后台 Activity 可触发 onDestroy@Overrideprotected void onDestroy() {    super.onDestroy();    Log.d(TAG, &quot;onDestroy() called&quot;);    new ReqGC().start();}@Overrideprotected void finalize() throws Throwable {    Log.d(TAG, &quot;finalize() called&quot;);    finish();    super.finalize();}@Overridepublic void finish() {    Log.d(TAG, &quot;finish() called&quot;);    setResult(RESULT_OK, new Intent().putExtra(&quot;key&quot;,             &quot;resultData&quot;));    super.finish();}// 不泄漏 Activity 对象static class ReqGC {     public void start() {        final Handler handler = new Handler();        handler.postDelayed(new Runnable() {            @Override            public void run() {                System.gc();                handler.postDelayed(this, 10);            }        }, 10);    }}</code></pre></li></ul><p>setResult不可以位于finish之后</p><ul><li>如果位于finish之后执行，那信息无法传递给源 Activity</li><li>从代码可以看出setResult和finish类似生产者/消费者模型，setResult 负责写入数据，finish 负责读取数据。</li></ul></blockquote><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><blockquote><ul><li><p>Activity.mResultCode 和 Activity.mResultData 变量由 Activity 对象的锁进行保护</p></li><li><p>支持后台线程和 UI 线程分别进行 setResult 和 finish</p></li><li><p>但是为什么需要加锁保护这两个信息？需要「解决什么问题」？</p></li></ul></blockquote><h4 id="API-设计-数据组装问题"><a href="#API-设计-数据组装问题" class="headerlink" title="API 设计/数据组装问题"></a>API 设计/数据组装问题</h4><blockquote><ul><li><p>底层 AMS 提供的接口的参数是 setResult 和 finish 的参数的组合形式，但是 Activity 为什么把一个接口拆分成两个接口给开发者使用？</p></li><li><p>使用方便。很多情况下调用者只关心 finish ，不需要理解太多的信息</p></li></ul></blockquote><h3 id="API-内部原理-数据处理流程"><a href="#API-内部原理-数据处理流程" class="headerlink" title="API 内部原理/数据处理流程"></a>API 内部原理/数据处理流程</h3><blockquote><p><a href="http://upload-images.jianshu.io/upload_images/6575830-cd7aada2f45de461.png" target="_blank" rel="noopener">链接：6575830-cd7aada2f45de461.png (PNG Image, 3632 × 34…</a></p><p>关键节点：</p><ul><li>Client 端通过 AMP 把数据发送给 Server 端 AMS Binder 实体</li><li>AMS 把数据包装成 ActivityResult 并保存在源 ActivityRecord 的 results 变量中</li><li>AMS 通过 ApplicationThreadProxy 向 Client 端发送 pause 信息让栈顶 Activity 进入 paused 状态，并等待 Client 端回复或超时</li><li>AMS 接收 Client 端已 paused 信息，恢复下一个获取焦点的 Activity ，读取之前保存在 ActivityRecord.results 变量的数据派发给 Client 端对应的 Activity</li><li>Client 端数据经过 ApplicationThread 对象、ActivityThread 对象的分发最后到达 Activity</li></ul></blockquote><h3 id="startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题"><a href="#startActivityForResult-和-singleTask-导致源-Activity-收不到正确结果问题" class="headerlink" title="startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题"></a>startActivityForResult 和 singleTask 导致源 Activity 收不到正确结果问题</h3><blockquote><ul><li><p>基本原则:源 Activity 和目标 Activity 无法在跨 Task 情况下通过 onActivityResult 传递数据</p></li><li><p>Android 5.0 以上 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「不会」创建新的 Task，因此可以收到正常回调</p><p> <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java#1196" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/core/ja…</a></p></li><li><p>Android 4.4.4 以下 AMS 在处理 manifest.xml 文件中的 singleTask 和 singleInstance 信息「会」创建新的 Task，因此在 startActivity 之后立即收到取消的回调</p><p> <a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java#1399" target="_blank" rel="noopener">链接：Cross Reference: /frameworks/base/services/java/co…</a></p></li><li><p>通过 dumpsys activity activities 命令查看 AMS 状态，验证两个 Activity 是否属于不同的 Task</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解startActivityForResult&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;startActivityForResul
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity的启动模式</title>
    <link href="http://yoursite.com/2018/02/02/activity-start/"/>
    <id>http://yoursite.com/2018/02/02/activity-start/</id>
    <published>2018-02-02T06:10:52.571Z</published>
    <updated>2018-02-02T07:44:45.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解Activity的启动模式</p><ol><li><p>Activity的启动模式有哪几种，分别用于什么场景？</p></li><li><p>清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</p></li></ol><h3 id="Activity的启动模式有哪几种，分别用于什么场景？"><a href="#Activity的启动模式有哪几种，分别用于什么场景？" class="headerlink" title="Activity的启动模式有哪几种，分别用于什么场景？"></a>Activity的启动模式有哪几种，分别用于什么场景？</h3><ul><li>standard: 标准模式</li></ul><blockquote><p>系统的默认模式。一种多实例模式，每次启动一个Activity都会重新创建一个新的实例。被启动的Activit会被放入启动者的栈中，如果启动者是除Activity之外的Context，如Application，此时没有任务栈，就会报错，<br>此时需指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。没有特殊需求都默认是这种模式。</p></blockquote><ul><li>singleTop: 栈顶复用模式</li></ul><blockquote><p>如果一个Activity的实例已经在栈顶存在，启动这个Activity时，不会创建新的Activity，而是回调onNewIntent方法，如果不是在栈顶存在，则创建一个新的实例。<br>适合接收通知启动的内容显示页面，当接收到多条新闻推送时，用户展示新闻的Activity设置成此模式，根据传过来的intent数据显示不同的新闻信息，不会起动多个activity。</p></blockquote><ul><li>singleTask: 栈内复用模式</li></ul><blockquote><p>一种单实例模式，只要Activity的实例在一个栈中存在，再一次启动Activity时都不会重新创建实例，只回调onNewIntent方法，并从栈中清空这个Activity实例上的所有Activity实例。<br>适合作为程序的入口点，例如浏览器的主页面，不管多少应用启动浏览器，只会启动主页面一次，其余情况都只回调onNewIntent方法，并且会清空主页面上的其他页面。</p></blockquote><ul><li>singleInstance: 单实例模式</li></ul><blockquote><p>具有singleTask的所有特性，设置此模式的Activity只能单独存在在一个任务栈中。</p><p>一个例子：闹铃响铃页面，你在16点设置了一个闹钟，在15点58的时候，你启动了闹钟设置页面，并按home键返回桌面，在15点59的时候你打开微信和朋友聊天，16点的时候闹钟响了，并且弹出一个对话框形式的Activity （AlarmAlertActivity，这个Activity是以singleInstance模式打开的）提示你16点到了，这时候你按返回键，返回的是微信聊天页，不是闹钟设置页面，因为AlarmAlertActivity以singleInstance模式打开，栈里只有它一个实例，退出后这个任务栈空了，如果以singleTask打开，这时候返回的是闹钟设置页面。</p></blockquote><h3 id="清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"><a href="#清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？" class="headerlink" title="清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？"></a>清晰地描述下onNewIntent和onConfigurationChanged这两个生命周期方法的场景？</h3><h4 id="onNewIntent"><a href="#onNewIntent" class="headerlink" title="onNewIntent"></a>onNewIntent</h4><blockquote><p>在singleTop、singleTask、singleInstance模式下再次启动相同的Activity，如果期望只有一个实例存在，再次启动就会调用onNewIntent，在onNewIntent中可以通过调用setIntents刷新Intent数据</p></blockquote><h4 id="onConfigurationChanged"><a href="#onConfigurationChanged" class="headerlink" title="onConfigurationChanged"></a>onConfigurationChanged</h4><blockquote><p>当Android设置正在运行app时，如果设备的语言，屏幕方向，键盘的参数改变了，默认会销毁当前Activity并重新创建一次Activity来重新加载新的配置信息。为了防止系统销毁，可以再<code>AndroidManifest.xml</code>文件中给Activity设置<code>android:configChanges</code>属性，可选值有<code>[&quot;mcc&quot;,&quot;mnc&quot;,&quot;locale&quot;,&quot;touchscreen&quot;,&quot;keyboard&quot;,&quot;keyboardHidden&quot;,&quot;navigation&quot;,&quot;screenLayout&quot;,&quot;fontScale&quot;,&quot;uiMode&quot;,&quot;orientation&quot;,&quot;density&quot;,&quot;screenSize&quot;,&quot;smallestScreenSize&quot;]</code>，申明的配置发生改变时，将不会重启Activity，而是回调onConfigurationChanged方法。如果设置的属性是<code>orientation</code>，当屏幕方向发生变化的时候，会阻止系统销毁Activity重新创建，而是保持运行，回调onConfigurationChanged方法，我们需要在onConfigurationChanged中做屏幕方向发生改变的操作，onConfigurationChanged会传递一个Configuration对象，通过读取这个对象的配置信息，来自行适配新的UI页面。</p></blockquote><pre><code>注：从Android 3.2(API 13)开始，当设备屏幕方向发生变化的时候，screenSize也会发生变化，因此需要设置android:configChanges=&quot;orientation|screenSize&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解Activity的启动模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Activity的启动模式有哪几种，分别用于什么场景？&lt;/p
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解Service</title>
    <link href="http://yoursite.com/2018/02/01/android-service/"/>
    <id>http://yoursite.com/2018/02/01/android-service/</id>
    <published>2018-02-01T13:53:44.006Z</published>
    <updated>2018-02-02T07:52:23.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>清晰地理解Service。</p><ul><li><p>Service的start和bind状态有什么区别？</p></li><li><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></li><li><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></li><li><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></li></ul><blockquote><p>Service的start和bind状态有什么区别：</p></blockquote><p> start启动的service，service有独立的生命周期，不依赖该组件；</p><p> 多次调用start方法，会重复调用onStartCommand方法；</p><p> start启动的service，必须调用stopService或者stopSelfl来停止service（IntentService会自动调用stopSelf方法）；</p><p> 多次调用bind方法，只会调用一次onBind方法，bind绑定的service，service依赖这些组件，这些组件全部销毁后，service也会一起销毁。</p><blockquote><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></blockquote><p>不论被start多少次，只需要stopService或者stopSelf一次；</p><p>调用n次bindService只需要调用一次unBindService；</p><p>所以，需要调用一次stopService（或者stopSelf）和一次unBindService方法，执行顺序没有要求，最后一个stopService（stopSelf）或者unBindService会导致Service执行onDestory方法。</p><blockquote><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></blockquote><p>一共有如下4种返回值：</p><pre><code>/**为了兼容版本，在Service被杀死后,并不保证onStartCommand会被再一次调用*/public static final int START_STICKY_COMPATIBILITY = 0;/**Service被杀死后，保留启动状态，但是不保存intent，之后系统会尝试重启Service，并重新回调onStartCommand方法，如果接下来没有其他start命令，intent会为空，因此要注意onStartCommand对intent的非空判断*/public static final int START_STICKY = 1;/**常规操作，除非在Service被杀死前还有组件调用startService,否则系统不会保留启动状态并重启该Service*/public static final int START_NOT_STICKY = 2;/**Service被杀死后，系统会组织一次Service的重启（除非在那之前调用了stopSelf方法），被杀死前最后一次传递的intent将重新执行，该flag不会传递空的intent。*/public static final int START_REDELIVER_INTENT = 3;</code></pre><blockquote><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></blockquote><p>Service默认是运行在主线程的，其生命周期方法也是运行在主线程：</p><p><img src="/2018/02/01/android-service/android-service.png" alt="service"></p><p>因此，如果要在Service中进行耗时操作，必须另起线程，或者用IntentService，否则很容易引起ANR。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;清晰地理解Service。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Service的start和bind状态有什么区别？&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解Java中的synchronized关键字</title>
    <link href="http://yoursite.com/2018/02/01/java-sunc/"/>
    <id>http://yoursite.com/2018/02/01/java-sunc/</id>
    <published>2018-02-01T13:40:42.542Z</published>
    <updated>2018-02-01T13:48:08.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。</p><p>有如下一个类A</p><pre><code>class A {    public synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><p>然后创建两个对象</p><pre><code>A a1 = new A();A a2 = new A();</code></pre><p>然后在两个线程中并发访问如下代码：</p><pre><code>Thread a1.a();Thread a2.a();public class Test {    public static void main(String[] args) {        A a1 = new A();        A a2 = new A();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a1.a();            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a2.a();            }        }).start();    }}</code></pre><p>请问二者能否构成线程同步？</p><p>如果A的定义是下面这种呢？</p><pre><code>class A {    public static synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public static synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>没有加static的时候结果是这样的:</p><p><img src="/2018/02/01/java-sunc/sync.jpg" alt="sync"></p><p>加了static的时候结果是这样的:</p><p><img src="/2018/02/01/java-sunc/sync1.jpg" alt="sync1"></p><p>可以看出，没有static时不能同步，有static时能同步。</p><p>Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。</p><p>Synchronized主修修饰对象为以下三种：</p><ol><li><p>修饰普通方法：一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象，如果多个线程不同对象访问该方法，则无法保证同步。</p></li><li><p>修饰静态方法：由于静态方法是类方法，所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</p></li><li><p>修饰代码块：其中普通代码块，如Synchronized（obj），这里的obj，可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p></li></ol><p>Synchronized方法控制范围较大，它会同步对象中所有Synchronized方法的代码。</p><p>Synchronized代码块控制范围较小，它只会同步代码块中的代码，而位于代码块之外的代码是可以被多个线程访问的。</p><p>简单来说 就是 Synchronized代码块更加灵活精确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/01/30/hello-world/"/>
    <id>http://yoursite.com/2018/01/30/hello-world/</id>
    <published>2018-01-30T08:56:01.913Z</published>
    <updated>2018-02-01T07:45:36.256Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo笔记" scheme="http://yoursite.com/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
