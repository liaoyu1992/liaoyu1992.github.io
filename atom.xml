<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝调华尔兹</title>
  
  <subtitle>每个人都曾经穿越不为人知的黑暗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-02T03:54:39.613Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YU.LIAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解Service</title>
    <link href="http://yoursite.com/2018/02/01/android-service/"/>
    <id>http://yoursite.com/2018/02/01/android-service/</id>
    <published>2018-02-01T13:53:44.006Z</published>
    <updated>2018-02-02T03:54:39.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>清晰地理解Service。</p><ul><li><p>Service的start和bind状态有什么区别？</p></li><li><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></li><li><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></li><li><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></li></ul><blockquote><p>Service的start和bind状态有什么区别：</p></blockquote><p> start启动的service，service有独立的生命周期，不依赖该组件；</p><p> 多次调用start方法，会重复调用onStartCommand方法；</p><p> start启动的service，必须调用stopService或者stopSelfl来停止service（IntentService会自动调用stopSelf方法）；</p><p> 多次调用bind方法，只会调用一次onBind方法，bind绑定的service，service依赖这些组件，这些组件全部销毁后，service也会一起销毁。</p><blockquote><p>同一个Service，先startService，然后再bindService，如何把它停止掉？</p></blockquote><p>不论被start多少次，只需要stopService或者stopSelf一次；</p><p>调用n次bindService只需要调用一次unBindService；</p><p>所以，需要调用一次stopService（或者stopSelf）和一次unBindService方法，执行顺序没有要求，最后一个stopService（stopSelf）或者unBindService会导致Service执行onDestory方法。</p><blockquote><p>你有注意到Service的onStartCommand方法的返回值吗？不同返回值有什么区别？</p></blockquote><p>一共有如下4种返回值：</p><pre><code>/**为了兼容版本，在Service被杀死后,并不保证onStartCommand会被再一次调用*/public static final int START_STICKY_COMPATIBILITY = 0;/**Service被杀死后，保留启动状态，但是不保存intent，之后系统会尝试重启Service，并重新回调onStartCommand方法，如果接下来没有其他start命令，intent会为空，因此要注意onStartCommand对intent的非空判断*/public static final int START_STICKY = 1;/**常规操作，除非在Service被杀死前还有组件调用startService,否则系统不会保留启动状态并重启该Service*/public static final int START_NOT_STICKY = 2;/**Service被杀死后，系统会组织一次Service的重启（除非在那之前调用了stopSelf方法），被杀死前最后一次传递的intent将重新执行，该flag不会传递空的intent。*/public static final int START_REDELIVER_INTENT = 3;</code></pre><blockquote><p>Service的生命周期方法onCreate、onStart、onBind等运行在哪个线程？</p></blockquote><p>Service默认是运行在主线程的，其生命周期方法也是运行在主线程：</p><p><img src="android-service/android-service.png" alt="service"></p><p>因此，如果要在Service中进行耗时操作，必须另起线程，或者用IntentService，否则很容易引起ANR。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;清晰地理解Service。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Service的start和bind状态有什么区别？&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解Java中的synchronized关键字</title>
    <link href="http://yoursite.com/2018/02/01/java-sunc/"/>
    <id>http://yoursite.com/2018/02/01/java-sunc/</id>
    <published>2018-02-01T13:40:42.542Z</published>
    <updated>2018-02-01T13:48:08.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。</p><p>有如下一个类A</p><pre><code>class A {    public synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><p>然后创建两个对象</p><pre><code>A a1 = new A();A a2 = new A();</code></pre><p>然后在两个线程中并发访问如下代码：</p><pre><code>Thread a1.a();Thread a2.a();public class Test {    public static void main(String[] args) {        A a1 = new A();        A a2 = new A();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a1.a();            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(System.currentTimeMillis());                a2.a();            }        }).start();    }}</code></pre><p>请问二者能否构成线程同步？</p><p>如果A的定义是下面这种呢？</p><pre><code>class A {    public static synchronized void a() {        System.out.println(&quot;a&quot;+System.currentTimeMillis());    }    public static synchronized void b() {        System.out.println(&quot;b&quot;+System.currentTimeMillis());    }}</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>没有加static的时候结果是这样的:</p><p><img src="java-sunc/sync.jpg" alt="sync"></p><p>加了static的时候结果是这样的:</p><p><img src="java-sunc/sync1.jpg" alt="sync1"></p><p>可以看出，没有static时不能同步，有static时能同步。</p><p>Java多线程中的同步机制会对资源进行加锁，保证在同一时间只有一个线程可以操作对应资源，避免多程同时访问相同资源发生冲突。Synchronized是Java中的关键字，它是一种同步锁，可以实现同步机制。</p><p>Synchronized主修修饰对象为以下三种：</p><ol><li><p>修饰普通方法：一个对象中的加锁方法只允许一个线程访问。但要注意这种情况下锁的是访问该方法的实例对象，如果多个线程不同对象访问该方法，则无法保证同步。</p></li><li><p>修饰静态方法：由于静态方法是类方法，所以这种情况下锁的是包含这个方法的类，也就是类对象；这样如果多个线程不同对象访问该静态方法，也是可以保证同步的。</p></li><li><p>修饰代码块：其中普通代码块，如Synchronized（obj），这里的obj，可以为类中的一个属性、也可以是当前的对象，它的同步效果和修饰普通方法一样；Synchronized方法 （obj.class）静态代码块它的同步效果和修饰静态方法类似。</p></li></ol><p>Synchronized方法控制范围较大，它会同步对象中所有Synchronized方法的代码。</p><p>Synchronized代码块控制范围较小，它只会同步代码块中的代码，而位于代码块之外的代码是可以被多个线程访问的。</p><p>简单来说 就是 Synchronized代码块更加灵活精确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h2&gt;&lt;p&gt;理解synchronized的含义、明确synchronized关键字修饰普通方法、静态方法和代码块时锁对象的差异。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Android学习计划" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/01/30/hello-world/"/>
    <id>http://yoursite.com/2018/01/30/hello-world/</id>
    <published>2018-01-30T08:56:01.913Z</published>
    <updated>2018-02-01T07:45:36.256Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo笔记" scheme="http://yoursite.com/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
